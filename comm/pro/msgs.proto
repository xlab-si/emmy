syntax = "proto3";

package comm;

// Valid schema types
enum SchemaType {
	PEDERSEN = 0;
	PEDERSEN_EC = 1;
	SCHNORR = 2;
	SCHNORR_EC = 3;
	PAILLIER = 4;
	PAILLIER_EC = 5;
}

// Valid schema variants
enum SchemaVariant {
	SIGMA = 0;	// Sigma protocol only. This is the default - if you don't specify schema variant, sigma will be used
	ZKP = 1;	// Zero knowledge proof
	ZKPOK = 2;	// Zero knowledge proof of knowledge
}

// A generic message
message Message {
	SchemaType schema = 1;
	SchemaVariant schema_variant = 2;
	oneof content {
		EmptyMsg empty = 3;
		BigInt bigint = 4;
		ECGroupElement ec_group_element = 5;
		Status status = 6;
		PedersenFirst pedersen_first = 7;
		PedersenDecommitment pedersen_decommitment = 8;
		SchnorrProofData schnorr_proof_data = 9;
		SchnorrProofRandomData schnorr_proof_random_data = 10;
		SchnorrECProofRandomData schnorr_ec_proof_random_data = 11;
		CSPaillierOpening cs_paillier_opening = 12;
		CSPaillierProofData cs_paillier_proof_data = 13;
		CSPaillierProofRandomData cs_paillier_proof_random_data = 14;
	}
	int32 clientId = 15;
}

// A generic service
service Protocol {
	rpc Run (stream Message) returns (stream Message) {}
}

// Generic request
// All fields except type are optional by default
message Request {
	SchemaType type = 1;
	// int sequence_number = ?

	EmptyMsg empty = 2;
	BigInt bigint = 3;
	PedersenDecommitment pedersen_decommitment = 4;
	ECGroupElement ec_group_element = 5;
	PedersenFirst pedersen_first = 6;
	SchnorrProofRandomData schnorr_proof_random_data = 7;
	SchnorrProofData schnorr_proof_data = 8;
	SchnorrECProofRandomData schnorr_ec_proof_random_data = 9;
}


// Generic response
// All fields except type are optional by default
message Response {
	SchemaType type = 1;

	EmptyMsg empty = 2;
	PedersenFirst pedersen_first = 3;
	ECGroupElement ec_group_element = 4;
	Status status = 5;
	PedersenDecommitment pedersen_decommitment = 6;
	BigInt bigint = 7;
}


// P, OrderOfSubgroup, G could be actually fixed, or least not changed each time
message PedersenFirst {
	bytes H = 1;
}

service Pedersen {
  rpc GetH(EmptyMsg) returns (PedersenFirst) {}
  rpc Commit(BigInt) returns (EmptyMsg) {}
  rpc Decommit(PedersenDecommitment) returns (Status) {}
}

service PedersenEC {
  rpc GetH(EmptyMsg) returns (ECGroupElement) {}
  rpc Commit(ECGroupElement) returns (EmptyMsg) {}
  rpc Decommit(PedersenDecommitment) returns (Status) {}
}

message PedersenECRequest {
	EmptyMsg empty = 1;
	BigInt commitVal = 2;
	PedersenDecommitment decommitment = 3;
	ECGroupElement ecge = 4;
}

message PedersenECResponse {
	PedersenFirst first = 1;
	ECGroupElement ecge = 2;
	EmptyMsg empty = 3;
	Status status = 4;
}

service PedersenECStream {
  rpc Commitment(stream PedersenECRequest) returns (stream PedersenECResponse) {}
}

message EmptyMsg {}

message PedersenDecommitment {
	bytes X = 1;
 	bytes R = 2;
}

message BigInt {
	bytes X1 = 1;
}

message ECGroupElement {
	bytes X = 1;
 	bytes Y = 2;
}

message Status {
	bool Success = 1;
}

message SchnorrProofRandomData {
	bytes X = 1;
	bytes A = 2;
	bytes B = 3;
}

service SchnorrProtocol {
  // OpeningMsg is called in ZKP and ZKPOK, input is Pedersen's h = g^a, output is challenge commitment
  rpc OpeningMsg(PedersenFirst) returns (BigInt) {}
  // PedersenDecommitment is used even it is not ZKP or ZKPOK (trapdoor is empty for SigmaProtocol)
  rpc ProofRandomData(SchnorrProofRandomData) returns (PedersenDecommitment) {}
  rpc ProofData(SchnorrProofData) returns (Status) {}
}

message SchnorrECProofRandomData {
	ECGroupElement X = 1;
	ECGroupElement A = 2;
	ECGroupElement B = 3;
}

service SchnorrECProtocol {
  // OpeningMsg is called in ZKP and ZKPOK, input is Pedersen's h = g^a, output is challenge commitment
  rpc OpeningMsg(ECGroupElement) returns (ECGroupElement) {} 
  // PedersenDecommitment is used even it is not ZKP or ZKPOK (trapdoor is empty for SigmaProtocol)
  rpc ProofRandomData(SchnorrECProofRandomData) returns (PedersenDecommitment) {}
  rpc ProofData(SchnorrProofData) returns (Status) {}
}

message SchnorrProofData {
	bytes Z = 1;
 	bytes Trapdoor = 2; // needed only in zero-knowledge proof of knowledge
}

message CSPaillierSecretKey {
	bytes N = 1;
	bytes G = 2;
	bytes X1 = 3;
	bytes X2 = 4;
	bytes X3 = 5;
	bytes DLogP = 6;
	bytes DLogG = 7;
	bytes DLogQ = 8;
	bytes VerifiableEncGroupN = 9;
	bytes VerifiableEncGroupG1 = 10;
	bytes VerifiableEncGroupH1 = 11;
	int32 K = 12;
	int32 K1 = 13;
}

message CSPaillierPubKey {
	bytes N = 1;
	bytes G = 2;
	bytes Y1 = 3;
	bytes Y2 = 4;
	bytes Y3 = 5;
	bytes DLogP = 6;
	bytes DLogG = 7;
	bytes DLogQ = 8;
	bytes VerifiableEncGroupN = 9;
	bytes VerifiableEncGroupG1 = 10;
	bytes VerifiableEncGroupH1 = 11;
	int32 K = 12;
	int32 K1 = 13;
}

message CSPaillierOpening {
	bytes U = 1;
	bytes E = 2;
	bytes V = 3;
	bytes Delta = 4;
	bytes Label = 5;
	bytes L = 6;
}

message CSPaillierProofRandomData {
	bytes U1 = 1;
	bytes E1 = 2;
	bytes V1 = 3;
	bytes Delta1 = 4;
	bytes L1 = 5;
}

message CSPaillierProofData {
	bytes RTilde = 1;
	bool RTildeIsNeg = 2;
	bytes STilde = 3;
	bool STildeIsNeg = 4;
	bytes MTilde = 5;
	bool MTildeIsNeg = 6;
}

service CSPaillierProtocol {
  rpc OpeningMsg(CSPaillierOpening) returns (EmptyMsg) {}
  rpc ProofRandomData(CSPaillierProofRandomData) returns (BigInt) {}
  rpc ProofData(CSPaillierProofData) returns (Status) {}
}









