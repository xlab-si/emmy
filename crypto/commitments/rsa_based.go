package commitments

import (
	"crypto/rand"
	"errors"
	"fmt"
	"github.com/xlab-si/emmy/crypto/common"
	"github.com/xlab-si/emmy/crypto/dlog"
	"math/big"
)

// GenerateRSABasedQOneWay generates RSA. RSA.Exp presents q-one-way homomorphism.
// QOneWayHomomorphism has the following property: it is difficult to compute a preimage of y^i
// for i < Q, but it is easy for i = Q. For RSABased computing preimage for y^Q is trivial: it is y.
func GenerateRSABasedQOneWay(nBitLength int) (func(*big.Int) *big.Int, func(*big.Int) *big.Int,
	common.Group, *big.Int, error) {
	rsa, err := dlog.NewRSA(nBitLength)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	q, err := rand.Prime(rand.Reader, rsa.N.BitLen()+1)
	if err != nil {
		return nil, nil, nil, nil, err
	}
	if q.Cmp(rsa.N) < 1 {
		return nil, nil, nil, nil, fmt.Errorf("Q must be > N")
	}
	rsa.E = q
	// given y^Q, homomorphismInv can compute x such that homomorphism(x) = y^Q.
	// Note: it takes y as input, not y^Q.
	// For RSABased it is trivial: identity. For other QOneHomomorphisms it might be different.
	homomorphismInv := func(y *big.Int) *big.Int {
		return y
	}
	// homomorphism is rsa.Exp
	H := common.NewZnGroup(rsa.N)

	return rsa.Exp, homomorphismInv, H, q, nil
}

// RSABasedCommitter implements commitment scheme based on (RSA based) q-one-way group homomorphism
// (scheme proposed by Cramer and Damgard). Commitment schemes based on q-one-way homomorphism
// have some nice properties - it can be proved in zero knowledge that a commitment
// contains 0 or 1 (see ProveBitCommitment) and it can be proved for A, B, C that C
// is commitment for a * b where A is commitment to a and B commitment to B.
type RSABasedCommitter struct {
	Homomorphism    func(*big.Int) *big.Int
	HomomorphismInv func(*big.Int) *big.Int
	H               common.Group
	Q               *big.Int
	Y               *big.Int
	committedValue  *big.Int
	r               *big.Int
}

// NewRSABasedCommitter takes n, q, y parameters which are generated by RSABasedCommitReceiver.
func NewRSABasedCommitter(homomorphism func(*big.Int) *big.Int, homomorphismInv func(*big.Int) *big.Int,
	H common.Group, q, y *big.Int) (*RSABasedCommitter, error) {
	// y must be from Im(f) where f(x) = x^q mod n, that means gcd(y, n) must be 1:
	// Note that for other q-one-way homomorphisms this validation would be different:
	yIsValid := H.IsElementInGroup(y)
	if !yIsValid {
		return nil, fmt.Errorf("Y is not valid")
	}
	return &RSABasedCommitter{
		Homomorphism:    homomorphism,
		HomomorphismInv: homomorphismInv,
		H:               H,
		Q:               q,
		Y:               y,
	}, nil
}

func (committer *RSABasedCommitter) GetCommitMsg(a *big.Int) (*big.Int, error) {
	if a.Cmp(committer.Q) != -1 {
		err := errors.New("the committed value needs to be < Q")
		return nil, err
	}
	c, r := committer.computeCommitment(a)
	committer.committedValue = a
	committer.r = r
	return c, nil
}

func (committer *RSABasedCommitter) computeCommitment(a *big.Int) (*big.Int, *big.Int) {
	// Y^a * r^Q mod N, where r is random from Z_N*
	r := committer.H.GetRandomElement()
	t1 := committer.H.Exp(committer.Y, a)
	t2 := committer.Homomorphism(r)
	c := committer.H.Mul(t1, t2)
	return c, r
}

func (committer *RSABasedCommitter) GetDecommitMsg() (*big.Int, *big.Int) {
	return committer.committedValue, committer.r
}

// GetCommitmentToMultiplication receives a, b, u where u is a random integer used in
// commitment B to b (B = y^b * QOneWayHomomorphism(u)). It returns commitment C to c = a * b mod Q,
// random integer o where C = y^(a*b) * QOneWayHomomorphism(o), and integer t such that
// C = B^a * QOneWayHomomorphism(t).
func (committer *RSABasedCommitter) GetCommitmentToMultiplication(a, b, u *big.Int) (*big.Int,
	*big.Int, *big.Int) {
	c := new(big.Int).Mul(a, b)
	cMod := new(big.Int).Mod(c, committer.Q) // c = a * b mod Q
	C, o := committer.computeCommitment(cMod)

	j := new(big.Int).Sub(c, cMod)
	j.Div(j, committer.Q)

	// We want t such that: C = B^a * f(t). We know C = y^(a*b) * f(o) and B^a = (y^a)^b) * f(u)^a.
	// t = o * u^(-a)
	uToa := committer.H.Exp(u, a)
	uToaInv := committer.H.Inv(uToa)
	t := committer.H.Mul(o, uToaInv)

	yToj := committer.H.Exp(committer.Y, j)
	yTojInv := committer.H.Inv(yToj)
	t1 := committer.HomomorphismInv(yTojInv)
	t = committer.H.Mul(t, t1)
	return C, o, t
}

type RSABasedCommitReceiver struct {
	Homomorphism    func(*big.Int) *big.Int
	HomomorphismInv func(*big.Int) *big.Int
	H               common.Group
	Q               *big.Int
	Y               *big.Int
	x               *big.Int
	commitment      *big.Int
}

func NewRSABasedCommitReceiver(nBitLength int) (*RSABasedCommitReceiver, error) {
	homomorphism, homomorphismInv, H, Q, err := GenerateRSABasedQOneWay(nBitLength)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}

	// gcd(q, phi(N)) is prime because q is prime and q > N > phi(N)
	// let's choose some x from Z_n*
	x := H.GetRandomElement()
	y := homomorphism(x)

	return &RSABasedCommitReceiver{
		Homomorphism:    homomorphism,
		HomomorphismInv: homomorphismInv,
		H:               H,
		Q:               Q,
		Y:               y,
		x:               x,
	}, nil
}

// When receiver receives a commitment, it stores the value using SetCommitment method.
func (receiver *RSABasedCommitReceiver) SetCommitment(c *big.Int) {
	receiver.commitment = c
}

func (receiver *RSABasedCommitReceiver) CheckDecommitment(r, a *big.Int) bool {
	t1 := receiver.H.Exp(receiver.Y, a)
	t2 := receiver.H.Exp(r, receiver.Q)
	c := receiver.H.Mul(t1, t2)
	return c.Cmp(receiver.commitment) == 0
}
